package com.gov.crypto.ca

import com.github.ajalt.clikt.core.CliktCommand
import com.github.ajalt.clikt.core.subcommands
import com.github.ajalt.clikt.parameters.options.default
import com.github.ajalt.clikt.parameters.options.flag
import com.github.ajalt.clikt.parameters.options.option
import com.github.ajalt.clikt.parameters.options.required
import com.gov.crypto.common.service.PqcCryptoService
import com.gov.crypto.common.service.PqcAlgorithm
import org.bouncycastle.asn1.ASN1ObjectIdentifier
import org.bouncycastle.asn1.x500.X500Name
import org.bouncycastle.asn1.x509.AlgorithmIdentifier
import org.bouncycastle.asn1.x509.BasicConstraints
import org.bouncycastle.asn1.x509.Extension
import org.bouncycastle.cert.X509v3CertificateBuilder
import org.bouncycastle.cert.bc.BcX509ExtensionUtils
import org.bouncycastle.crypto.params.AsymmetricKeyParameter
import org.bouncycastle.operator.ContentSigner
import org.bouncycastle.pqc.crypto.slhdsa.SLHDSAPrivateKeyParameters
import org.bouncycastle.pqc.crypto.slhdsa.SLHDSASigner
import org.bouncycastle.pqc.crypto.util.PrivateKeyFactory
import org.bouncycastle.pqc.crypto.util.PrivateKeyInfoFactory
import org.bouncycastle.pqc.crypto.util.SubjectPublicKeyInfoFactory
import org.bouncycastle.util.io.pem.PemObject
import org.bouncycastle.util.io.pem.PemWriter
import java.io.ByteArrayOutputStream
import java.io.File
import java.io.FileReader
import java.io.OutputStream
import java.math.BigInteger
import java.util.Date

// --- Adapter to usage BC Lightweight Signer with Certificate Builder ---
class SlhDsaContentSigner(
    private val privateKey: SLHDSAPrivateKeyParameters,
    private val sigAlgId: AlgorithmIdentifier
) : ContentSigner {
    private val output = ByteArrayOutputStream()
    private val signer = SLHDSASigner()

    init {
        signer.init(true, privateKey)
    }

    override fun getAlgorithmIdentifier(): AlgorithmIdentifier = sigAlgId

    override fun getOutputStream(): OutputStream = output

    override fun getSignature(): ByteArray {
        return signer.generateSignature(output.toByteArray())
    }
}

class CaCli : CliktCommand() {
    override fun run() {}
}

class InitRoot : CliktCommand(help = "Initialize Root CA (SLH-DSA)") {
    override fun run() {
        echo("Initializing Root CA with SLH-DSA...")
        val service = PqcCryptoService()
        // Generate Keys using common-crypto service (which uses Lightweight API internally)
        val bcKeyPair = service.generateKeyPair(PqcAlgorithm.SLH_DSA_SHAKE_128F)
        
        // 1. Prepare Key Info for Storage
        val privateKeyInfo = PrivateKeyInfoFactory.createPrivateKeyInfo(bcKeyPair.private)
        val publicKeyInfo = SubjectPublicKeyInfoFactory.createSubjectPublicKeyInfo(bcKeyPair.public)
        
        // 2. Prepare Signer
        // OID for SLH-DSA-SHAKE-128f (FIPS 205): 2.16.840.1.101.3.4.3.21
        val oid = ASN1ObjectIdentifier("2.16.840.1.101.3.4.3.21")
        val sigAlgId = AlgorithmIdentifier(oid)
        
        val signer = SlhDsaContentSigner(bcKeyPair.private as SLHDSAPrivateKeyParameters, sigAlgId)

        // 3. Build Self-Signed Certificate
        val expiry = Date(System.currentTimeMillis() + 3650L * 24 * 60 * 60 * 1000) // 10 years
        val name = X500Name("CN=Offline Root CA, O=Gov Crypto, C=VN")

        // FIX: Use generic X509v3CertificateBuilder to avoid BcX509v3CertificateBuilder using wrong helper
        val builder = X509v3CertificateBuilder(
            name,
            BigInteger.valueOf(System.currentTimeMillis()),
            Date(),
            expiry,
            name,
            publicKeyInfo // Pass SubjectPublicKeyInfo explicitly (generated by PQC factory)
        )
        
        val extUtils = BcX509ExtensionUtils()
        builder.addExtension(Extension.basicConstraints, true, BasicConstraints(true))
        // Use the overload that takes SubjectPublicKeyInfo (avoiding re-conversion failure)
        builder.addExtension(Extension.subjectKeyIdentifier, false, extUtils.createSubjectKeyIdentifier(publicKeyInfo))

        val holder = builder.build(signer)
        
        // 4. Write PEM Files
        File("root-ca.key").bufferedWriter().use { 
            val pemWriter = PemWriter(it)
            pemWriter.writeObject(PemObject("PRIVATE KEY", privateKeyInfo.encoded))
            pemWriter.flush()
        }
        
        File("root-ca.crt").bufferedWriter().use {
             val pemWriter = PemWriter(it)
             pemWriter.writeObject(PemObject("CERTIFICATE", holder.encoded))
             pemWriter.flush()
        }
        
        echo("Root CA generated: root-ca.key, root-ca.crt")
    }
}

class IssueCert : CliktCommand(help = "Issue a Certificate signed by Root CA") {
    private val subjectDn by option(help="Subject DN").required()
    private val rootKeyPath by option(help="Path to Root Key PEM").default("root-ca.key")
    private val outputPrefix by option(help="Output filename prefix").required()
    private val isCa by option(help="Is Intermediate CA?").flag()

    override fun run() {
        echo("Issuing certificate for $subjectDn...")
        
        // 1. Load Root Key (Parse ASN1 -> BC Params)
        val pemParser = org.bouncycastle.openssl.PEMParser(FileReader(rootKeyPath))
        val obj = pemParser.readObject() // Expects PrivateKeyInfo (from our init-root Output)
        
        val rootKeyParams = if (obj is org.bouncycastle.asn1.pkcs.PrivateKeyInfo) {
             PrivateKeyFactory.createKey(obj)
        } else {
             // Fallback if PEMParser returns PEMKeyPair or other wrapper
             throw IllegalArgumentException("Invalid key format: ${obj?.javaClass?.name}. Expected PrivateKeyInfo.")
        }

        if (rootKeyParams !is SLHDSAPrivateKeyParameters) {
            throw IllegalArgumentException("Root key must be SLH-DSA")
        }
        
        // Reconstruct KeyInfo just to get Algorithm ID if needed, 
        // or hardcode since we know it's the Root CA Key.
        // Let's safe-guard by reading it from the PrivateKeyInfo object we read.
        val rootKeyInfo = (obj as org.bouncycastle.asn1.pkcs.PrivateKeyInfo)
        val sigAlgId = rootKeyInfo.privateKeyAlgorithm

        // 2. Generate Subject KeyPair (New User/Service Key)
        val service = PqcCryptoService()
        // Intermediate CAs use SLH-DSA, End Entities (Services) use ML-DSA
        val algo = if (isCa) PqcAlgorithm.SLH_DSA_SHAKE_128F else PqcAlgorithm.ML_DSA_65
        val bcKeyPair = service.generateKeyPair(algo)
        
        val publicKeyInfo = SubjectPublicKeyInfoFactory.createSubjectPublicKeyInfo(bcKeyPair.public)
        val privateKeyInfo = PrivateKeyInfoFactory.createPrivateKeyInfo(bcKeyPair.private)

        // 3. Build Certificate
        val expiry = Date(System.currentTimeMillis() + 365L * 24 * 60 * 60 * 1000) // 1 year
        val issuerName = X500Name("CN=Offline Root CA, O=Gov Crypto, C=VN") 
        val subjectName = X500Name(subjectDn)
        
        val signer = SlhDsaContentSigner(rootKeyParams, sigAlgId)

        val builder = X509v3CertificateBuilder(
            issuerName,
            BigInteger.valueOf(System.currentTimeMillis()),
            Date(),
            expiry,
            subjectName,
            publicKeyInfo
        )
        
        val extUtils = BcX509ExtensionUtils()
        builder.addExtension(Extension.basicConstraints, true, BasicConstraints(isCa))
        builder.addExtension(Extension.subjectKeyIdentifier, false, extUtils.createSubjectKeyIdentifier(publicKeyInfo))

        val holder = builder.build(signer)

        // 4. Save
        File("$outputPrefix.key").bufferedWriter().use { 
            val pemWriter = PemWriter(it)
            pemWriter.writeObject(PemObject("PRIVATE KEY", privateKeyInfo.encoded))
            pemWriter.flush()
        }
        
        File("$outputPrefix.crt").bufferedWriter().use {
             val pemWriter = PemWriter(it)
             pemWriter.writeObject(PemObject("CERTIFICATE", holder.encoded))
             pemWriter.flush()
        }
        echo("Issued: $outputPrefix.key, $outputPrefix.crt")
    }
}

fun main(args: Array<String>) = CaCli().subcommands(InitRoot(), IssueCert()).main(args)
